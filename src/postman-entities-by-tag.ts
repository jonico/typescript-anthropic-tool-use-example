// Postman API Tool: Get Elements by Tag
// Generated by MCP Toolgen
import { z } from 'zod';

export type GetElementsByTagParams = {
  slugId: string;
  limit?: number;
  direction?: 'asc' | 'desc';
  cursor?: string;
  entityType?: 'api' | 'collection' | 'workspace';
};

export type EntityType = 'collection' | 'api' | 'workspace';

export type Entity = {
  entityId: string;
  entityType: EntityType;
};

export type Meta = {
  count: number;
  nextCursor?: string;
};

export type SuccessfulResponse = {
  data: {
    entities: Entity[];
  };
  meta: Meta;
};

export type ErrorResponse = {
  type: string;
  title: string;
  detail: string;
  status: number;
};

export const getElementsByTag = async ({
  slugId,
  limit,
  direction,
  cursor,
  entityType,
}: GetElementsByTagParams): Promise<SuccessfulResponse | ErrorResponse> => {
  const baseUrl = 'https://api.getpostman.com';
  const apiKey = process.env.POSTMAN_API_KEY || '';

  try {
    // Construct the URL with path and query parameters
    const url = new URL(`${baseUrl}/tags/${slugId}/entities`);
    if (limit) url.searchParams.append('limit', limit.toString());
    if (direction) url.searchParams.append('direction', direction);
    if (cursor) url.searchParams.append('cursor', cursor);
    if (entityType) url.searchParams.append('entityType', entityType);

    // Set up headers for the request
    const headers: Record<string, string> = {
      'X-API-Key': apiKey,
      'Accept': 'application/vnd.api.v10+json',
    };

    // Perform the fetch request
    const response = await fetch(url.toString(), {
      method: 'GET',
      headers,
    });

    // Check if the response was successful
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(JSON.stringify(errorData));
    }

    // Parse and return the response data
    const data = await response.json();
    return data as SuccessfulResponse;
  } catch (error) {
    console.error('Error getting elements by tag:', error);
    return { type: 'https://api.postman.com/problems/internal-server-error', title: 'Something went wrong', detail: 'An error occurred while fetching elements.', status: 500 };
  }
};

export const postmanEntitiesByTagTool = {
  function: getElementsByTag,
  definition: {
    name: 'get_elements_by_tag',
    description: 'Get Postman elements by a given tag.',
    input_schema: {
      type: 'object',
      properties: {
        slugId: {
          type: 'string',
          description: 'The tag\'s ID within a team or individual (non-team) user scope.'
        },
        limit: {
          type: 'integer',
          description: 'The maximum number of tagged elements to return in a single call.'
        },
        direction: {
          type: 'string',
          enum: ['asc', 'desc'],
          description: 'The order to sort the results by, based on the time of the element\'s tagging.'
        },
        cursor: {
          type: 'string',
          description: 'The cursor to get the next set of results in the paginated response.'
        },
        entityType: {
          type: 'string',
          enum: ['api', 'collection', 'workspace'],
          description: 'Filter results for the given element type.'
        }
      },
      required: ['slugId'],
      additionalProperties: false
    }
  }
};

export const getElementsByTagZodSchema = {
  slugId: z.string().describe("The tag's ID within a team or individual (non-team) user scope."),
  limit: z.number().int().optional().describe('The maximum number of tagged elements to return in a single call.'),
  direction: z.enum(['asc', 'desc']).optional().describe("The order to sort the results by, based on the time of the element's tagging."),
  cursor: z.string().optional().describe('The cursor to get the next set of results in the paginated response.'),
  entityType: z.enum(['api', 'collection', 'workspace']).optional().describe('Filter results for the given element type.'),
};
